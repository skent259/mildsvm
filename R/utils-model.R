#' Store the levels of y and convert to 0,1 numeric format.
#' @inheritParams .reorder
#' @noRd
convert_y <- function(y) {
  y <- factor(y)
  lev <- levels(y)
  if (length(lev) == 1) {
    stop(paste0("Response y has only one level, ", lev, ", cannot perform misvm fitting."))
  } else if (length(lev) > 2) {
    stop(paste0("Response y has more than two levels, ", lev, ", cannot perform misvm fitting."))
  }
  if (lev[1] == 1 | lev[1] == "1" | lev[1] == TRUE) {
    lev <- rev(lev)
    y <- factor(y, levels = lev) # make sure 1 is second level
  } else if (lev[2] != 1 & lev[2] != "1" & lev[2] != TRUE) {
    message(paste0("Setting level ", lev[2], " to be the positive class for misvm fitting."))
  } # else lev[2] is like 1, keep it that way.
  y <- as.numeric(y) - 1
  list(y = y, lev = lev)
}

#' Calculate x-matrix from a standard formula
#' @inheritParams smm
#' @param skip a vector of variable names to skip, or `NULL` to keep all
#'   (default `NULL`).
#' @noRd
x_from_formula <- function(formula, data, skip = NULL) {
  response <- as.character(formula[[2]])
  skip <- c(skip, response)
  predictors <- setdiff(colnames(data), skip)

  x <- stats::model.matrix(formula[-2], data = data[, predictors, drop = FALSE])
  if (attr(stats::terms(formula, data = data), "intercept") == 1) x <- x[, -1, drop = FALSE]
  x <- as.data.frame(x)
}

#' Calculate x-matrix from a formula with `mi()` in it
#' @inheritParams misvm
#' @noRd
x_from_mi_formula <- function(formula, data) {
  mi_names <- as.character(stats::terms(formula, data = data)[[2]])
  bag_label <- mi_names[[2]]
  bag_name <- mi_names[[3]]
  predictors <- setdiff(colnames(data), c(bag_label, bag_name))

  x <- stats::model.matrix(formula[-2], data = data[, predictors, drop = FALSE])
  if (attr(stats::terms(formula, data = data), "intercept") == 1) x <- x[, -1, drop = FALSE]
  x <- as.data.frame(x)
}

#' Calculate x-matrix from a formula with `mild()` in it
#' @inheritParams mildsvm
#' @noRd
x_from_mild_formula <- function(formula, data) {
  mild_names <- as.character(stats::terms(formula, data = data)[[2]])
  bag_label <- mild_names[[2]]
  bag_name <- mild_names[[3]]
  instance_name <- mild_names[[4]]
  predictors <- setdiff(colnames(data), c(bag_label, bag_name, instance_name))

  x <- stats::model.matrix(formula[-2], data = data[, predictors, drop = FALSE])
  if (attr(stats::terms(formula, data = data), "intercept") == 1) x <- x[, -1, drop = FALSE]
  x <- as.data.frame(x)
}

#' Initialize Instance Selection
#'
#' Use bag_label and instance_name information to initialize the selected
#' instances. When bag label is 0, select all instances.  When bag label is
#' 1, select the first instance in each bag.
#' @param data A mild_df object, potentially generated by mild_df().
#' @return A list of 3:
#'   * `useful_inst_names` includes the names of instances that were selected.
#'   * `useful_inst_idx` includes the index of instances that were selected, at
#'   the instance level
#'   * `yy` includes the bag labels, at the instance level
#' @noRd
initialize_instance_selection <- function(data) {
  s_bag <- split(data, factor(data$bag_name, levels = unique(data$bag_name)))
  unique_bag_label <- function(x) { unique(x$bag_label) }
  unique_instance_name <- function(x) { unique(x$instance_name) }
  select_useful_inst <- function(label, name) { if (label == 1) {name[1]} else {name}}

  labels <- lapply(s_bag, FUN = unique_bag_label)
  instance_names <- lapply(s_bag, FUN = unique_instance_name)
  useful_inst_names <- unlist(mapply(FUN = select_useful_inst,
                                     label = labels,
                                     name = instance_names),
                              use.names = FALSE)
  useful_inst_idx <- which(unique(data$instance_name) %in% useful_inst_names)

  s_inst <- split(data, factor(data$instance_name, levels = unique(data$instance_name)))
  yy <-  unlist(lapply(s_inst, FUN = unique_bag_label),
                use.names = FALSE)
  yy <- factor(yy, levels = c(-1, 1), labels = c("-1", "1"))  ## change yy to a factor.

  return(list(useful_inst_names = useful_inst_names,
              useful_inst_idx = useful_inst_idx,
              yy = yy))
}

#' Select Cross Validation folds from mild_df
#'
#' Uses the bag information from a `data` object to generate folds for use in
#' cross validation.
#'
#' @inheritParams initialize_instance_selection
#' @inheritParams cv_misvm
#'
#' @return A list with the following components:
#'   - `n_fold` the number of folds for cross validation.
#'   - `fold_id` if fold_id is missing in input, returns the folds calculated by
#'   splitting the positive and negative bags separately.
#'
#' @noRd
select_cv_folds <- function(data, n_fold, fold_id) {
  # TODO: I think I can make this a lot cleaner with the following idea from my other code
  # bags_for_train <- which(foldid != fold)
  # ind <- bags %in% unique(bags)[bags_for_train]
  # # The last line goes from the bag index to the instance index, avoiding right joins

  bag_info <- unique(data[, c("bag_label", "bag_name"), drop = FALSE])
  if (missing(fold_id)) {
    if (missing(n_fold))
      n_fold <- 5

    positive_bag_idx <- which(bag_info$bag_label == 1)
    negative_bag_idx <- which(bag_info$bag_label == 0)
    positive_fold_id <- .resample(seq_along(positive_bag_idx) %% n_fold + 1)
    negative_fold_id <- .resample(seq_along(negative_bag_idx) %% n_fold + 1)

    bag_id <- numeric(nrow(bag_info))
    bag_id[positive_bag_idx] <- positive_fold_id
    bag_id[negative_bag_idx] <- negative_fold_id

    temp_data <- data.frame(bag_name = unique(data$bag_name),
                            bag_id = bag_id,
                            stringsAsFactors = FALSE) %>%
      dplyr::right_join(unique(data %>% dplyr::select(.data$bag_name, .data$instance_name)),
                        by = "bag_name")
    fold_id <- temp_data$bag_id  ## now fold_id is of length(unique(data$instance_name))
  } else {
    n_fold <- max(fold_id)
    if (!is.null(setdiff(fold_id, 1:n_fold)))
      stop("The argument fold_id has some 'holes'!")
  }
  return(list(n_fold = n_fold, fold_id = fold_id))
}

#' Function that will eventually supercede select_cv_folds because it supports
#' the same variables as `misvm()`, `mildsvm()` and `smm()`.
#' @inheritParams classify_bags
#' @inheritParams select_cv_folds
#' @noRd
select_cv_folds2 <- function(y, bags, n_fold, fold_id) {

  info <- data.frame(y = y, bags = bags)
  info_bag_layer <- unique(info)

  if (missing(fold_id)) {
    if (missing(n_fold))
      n_fold <- 5

    positive_bag_idx <- which(info_bag_layer$y == 1)
    negative_bag_idx <- which(info_bag_layer$y == 0)
    positive_fold_id <- .resample(seq_along(positive_bag_idx) %% n_fold + 1)
    negative_fold_id <- .resample(seq_along(negative_bag_idx) %% n_fold + 1)

    bag_id <- numeric(nrow(info_bag_layer))
    bag_id[positive_bag_idx] <- positive_fold_id
    bag_id[negative_bag_idx] <- negative_fold_id
    info_bag_layer$bag_id <- bag_id

    tmp <- info %>%
      dplyr::left_join(info_bag_layer, by = c("bags", "y"))

    fold_id <- tmp$bag_id
  } else {
    n_fold <- max(fold_id)
    if (!is.null(setdiff(fold_id, 1:n_fold)))
      stop("The argument fold_id has some 'holes'!")
  }
  return(list(n_fold = n_fold, fold_id = fold_id))
}
