`%ni%` <- Negate(`%in%`)

#' Function to reorder the data by bag label, bag number, and then first data
#' column
#'
#' @keywords internal
.reorder <- function(y, b, X) {
  b <- as.numeric(as.factor(b))
  ## order by bag label (negative first), and then order data by bag
  data_order <- order(y, b, X[,1])

  list(y = y[data_order],
       b = b[data_order],
       X = as.matrix(X[data_order, ]))
}

#' Classify y from bags
#'
#' @param y a numeric vector of bag labels with length equal to the number of
#'   instances (not the number of bags). Must have -1 for negative bags and
#'   +1 for positive bags
#' @param bags a vector specifying which instance belongs to each bag.  Can be
#'   a string, numeric, of factor
#' @param condense whether to return classification at the level of unique bags or not
#' @return a named vector of length `length(unique(b))` which gives the
#'   classification for each bag.  Names come from `bags`.
#' @export
#' @author Sean Kent
classify_bags <- function(y, bags, condense = TRUE) {
  # works whether y is {-1, 1} or {0, 1} as long as 1 reflects a positive instance
  if (condense) {
    res <- sapply(unique(bags), function(b) max(y[b == bags]))
    names(res) <- unique(bags)
  } else {
    res <- sapply(bags, function(b) max(y[b == bags]))
  }
  return(res)
}

#' Initialize Instance Selection
#'
#' Use bag_label and instance_name information to initialize the selected
#' instances. When bag label is 0, select all instances.  When bag label is
#' 1, select the first instance in each bag.
#' @param data A MilData object, potentially generated by MilData().
#' @return list of 3:
#'     'useful_inst_names' includes the names of instances that were selected.
#'     'useful_inst_idx' includes the index of instances that were selected, at the instance level
#'     'yy' includes the bag labels, at the instance level
#' @examples
#' x = MilData(data.frame('bag_label' = factor(c(1, 1, 0)),
#'                        'bag_name' = c(rep('bag_1', 2), 'bag_2'),
#'                        'instance_name' = c('bag_1_inst_1', 'bag_1_inst_2', 'bag_2_inst_1'),
#'                        'X1' = c(-0.4, 0.5, 2),
#'                        'instance_label' = c(0, 1, 0)))
#'
#' initialize_instance_selection(x)
#'
#' @keywords internal
#' @author Sean Kent
initialize_instance_selection <- function(data) {
  s_bag <- split(data, factor(data$bag_name, levels = unique(data$bag_name)))
  unique_bag_label <- function(x) { unique(x$bag_label) }
  unique_instance_name <- function(x) { unique(x$instance_name) }
  select_useful_inst <- function(label, name) { if (label == 1) {name[1]} else {name}}

  labels <- lapply(s_bag, FUN = unique_bag_label)
  instance_names <- lapply(s_bag, FUN = unique_instance_name)
  useful_inst_names <- unlist(mapply(FUN = select_useful_inst,
                                     label = labels,
                                     name = instance_names),
                              use.names = FALSE)
  useful_inst_idx <- which(unique(data$instance_name) %in% useful_inst_names)

  s_inst <- split(data, factor(data$instance_name, levels = unique(data$instance_name)))
  yy <-  unlist(lapply(s_inst, FUN = unique_bag_label),
                use.names = FALSE)
  yy <- factor(yy, levels = c(0, 1), labels = c("0", "1"))  ## change yy to a factor.

  return(list(useful_inst_names = useful_inst_names,
              useful_inst_idx = useful_inst_idx,
              yy = yy))
}

#' Select Cross Validation folds from MilData
#'
#' Uses the bag information from a `data` object to generate folds for use in
#' cross validation.
#' @param data A MilData object, potentially generated by MilData().
#' @param n_fold the number of folds for cross validation
#' @param fold_id A user specified fold_id. Suggested not to specify
#'   this.
#'
#' @return a list with the following components:
#'   - `n_fold` the number of folds for cross validatoin
#'   - `fold_id` if fold_id is missing in input, returns the folds calculated by
#'   splitting the positive and negative bags separately.
#'
#' @keywords internal
#' @author Yifei Liu, Sean Kent
select_cv_folds <- function(data, n_fold, fold_id) {
  # TODO: I think I can make this a lot cleaner with the following idea from my other code
  # bags_for_train <- which(foldid != fold)
  # ind <- bags %in% unique(bags)[bags_for_train]
  # # The last line goes from the bag index to the instance index, avoiding right joins

  bag_info <- unique(data[, c("bag_label", "bag_name")])
  if (missing(fold_id)) {
    if (missing(n_fold))
      n_fold <- 5

    positive_bag_idx <- which(bag_info$bag_label == 1)
    negative_bag_idx <- which(bag_info$bag_label == 0)
    positive_fold_id <- base::sample((1:length(positive_bag_idx))%%n_fold + 1)
    negative_fold_id <- base::sample((1:length(negative_bag_idx))%%n_fold + 1)

    bag_id <- numeric(nrow(bag_info))
    bag_id[positive_bag_idx] <- positive_fold_id
    bag_id[negative_bag_idx] <- negative_fold_id

    temp_data <- data.frame(bag_name = unique(data$bag_name),
                            bag_id = bag_id,
                            stringsAsFactors = FALSE) %>%
      dplyr::right_join(unique(data %>% dplyr::select(bag_name, instance_name)),
                        by = "bag_name")
    fold_id <- temp_data$bag_id  ## now fold_id is of length(unique(data$instance_name))
  } else {
    n_fold <- max(fold_id)
    if (!is.null(setdiff(fold_id, 1:n_fold)))
      stop("The argument fold_id has some 'holes'!")
  }
  return(list(n_fold = n_fold, fold_id = fold_id))
}

#' Function that will eventually supercede select_cv_folds because it supports
#' the same variables at the new function interface.
#' @keywords internal
select_cv_folds2 <- function(y, bags, n_fold, fold_id) {

  info <- data.frame(y = y, bags = bags)
  info_bag_layer <- unique(info)

  if (missing(fold_id)) {
    if (missing(n_fold))
      n_fold <- 5

    positive_bag_idx <- which(info_bag_layer$y == 1)
    negative_bag_idx <- which(info_bag_layer$y == 0)
    positive_fold_id <- base::sample((1:length(positive_bag_idx))%%n_fold + 1)
    negative_fold_id <- base::sample((1:length(negative_bag_idx))%%n_fold + 1)

    bag_id <- numeric(nrow(info_bag_layer))
    bag_id[positive_bag_idx] <- positive_fold_id
    bag_id[negative_bag_idx] <- negative_fold_id
    info_bag_layer$bag_id <- bag_id

    tmp <- info %>%
      dplyr::left_join(info_bag_layer, by = c("bags", "y"))

    fold_id <- tmp$bag_id
    # fold_id <- temp_data$bag_id  ## now fold_id is of length(unique(data$instance_name))
  } else {
    n_fold <- max(fold_id)
    if (!is.null(setdiff(fold_id, 1:n_fold)))
      stop("The argument fold_id has some 'holes'!")
  }
  return(list(n_fold = n_fold, fold_id = fold_id))
}

x_from_formula <- function(formula, data) {
  mi_names <- as.character(terms(formula, data = data)[[2]])
  bag_label <- mi_names[[2]]
  bag_name <- mi_names[[3]]
  predictors <- setdiff(colnames(data), c(bag_label, bag_name))

  x <- model.matrix(formula[-2], data = data[, predictors])
  if (attr(terms(formula, data = data), "intercept") == 1) x <- x[, -1, drop = FALSE]
  x <- as.data.frame(x)
}

#' Store the levels of y and convert to 0,1 numeric format.
#' @keywords internal
#' @author Sean Kent
convert_y <- function(y) {
  y <- factor(y)
  lev <- levels(y)
  if (length(lev) == 1) {
    stop(paste0("Response y has only one level, ", lev, ", cannot perform misvm fitting."))
  } else if (length(lev) > 2) {
    stop(paste0("Response y has more than two levels, ", lev, ", cannot perform misvm fitting."))
  }
  if (lev[1] == 1 | lev[1] == "1" | lev[1] == TRUE) {
    lev <- rev(lev)
    y <- factor(y, levels = lev) # make sure 1 is second level
  } else if (lev[2] != 1 & lev[2] != "1" & lev[2] != TRUE) {
    message(paste0("Setting level ", lev[2], " to be the positive class for misvm fitting."))
  } # else lev[2] is like 1, keep it that way.
  y <- as.numeric(y) - 1
  list(y = y, lev = lev)
}
