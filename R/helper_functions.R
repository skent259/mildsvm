`%ni%` <- Negate(`%in%`)

#' Function to reorder the data by bag label, bag number, and then first data
#' column
#'
#' @keywords internal
.reorder <- function(y, b, X) {
  b <- as.numeric(as.factor(b))
  ## order by bag label (negative first), and then order data by bag
  data_order <- order(y, b, X[,1])

  list(y = y[data_order],
       b = b[data_order],
       X = as.matrix(X[data_order, ]))
}

#' Classify y from bags
#'
#' @param y a numeric vector of bag labels with length equal to the number of
#'   instances (not the number of bags). Must have -1 for negative bags and
#'   +1 for positive bags
#' @param bags a vector specifying which instance belongs to each bag.  Can be
#'   a string, numeric, of factor
#' @param condense whether to return classification at the level of unique bags or not
#' @return a named vector of length `length(unique(b))` which gives the
#'   classification for each bag.  Names come from `bags`.
#' @export
#' @author Sean Kent
classify_bags <- function(y, bags, condense = TRUE) {
  # works whether y is {-1, 1} or {0, 1} as long as 1 reflects a positive instance
  if (condense) {
    res <- sapply(unique(bags), function(b) max(y[b == bags]))
    names(res) <- unique(bags)
  } else {
    res <- sapply(bags, function(b) max(y[b == bags]))
  }
  return(res)
}

#' Initialize Instance Selection
#'
#' Use bag_label and instance_name information to initialize the selected
#' instances. When bag label is 0, select all instances.  When bag label is
#' 1, select the first instance in each bag.
#' @param data A MilData object, potentially generated by MilData().
#' @return list of 3:
#'     'useful_inst_names' includes the names of instances that were selected.
#'     'useful_inst_idx' includes the index of instances that were selected, at the instance level
#'     'yy' includes the bag labels, at the instance level
#' @examples
#' x = MilData(data.frame('bag_label' = factor(c(1, 1, 0)),
#'                        'bag_name' = c(rep('bag_1', 2), 'bag_2'),
#'                        'instance_name' = c('bag_1_inst_1', 'bag_1_inst_2', 'bag_2_inst_1'),
#'                        'X1' = c(-0.4, 0.5, 2),
#'                        'instance_label' = c(0, 1, 0)))
#'
#' initialize_instance_selection(x)
#'
#' @keywords internal
#' @author Sean Kent
initialize_instance_selection <- function(data) {
  s_bag <- split(data, factor(data$bag_name, levels = unique(data$bag_name)))
  unique_bag_label <- function(x) { unique(x$bag_label) }
  unique_instance_name <- function(x) { unique(x$instance_name) }
  select_useful_inst <- function(label, name) { if (label == 1) {name[1]} else {name}}

  labels <- lapply(s_bag, FUN = unique_bag_label)
  instance_names <- lapply(s_bag, FUN = unique_instance_name)
  useful_inst_names <- unlist(mapply(FUN = select_useful_inst,
                                     label = labels,
                                     name = instance_names),
                              use.names = FALSE)
  useful_inst_idx <- which(unique(data$instance_name) %in% useful_inst_names)

  s_inst <- split(data, factor(data$instance_name, levels = unique(data$instance_name)))
  yy <-  unlist(lapply(s_inst, FUN = unique_bag_label),
                use.names = FALSE)
  yy <- factor(yy, levels = c(0, 1), labels = c("0", "1"))  ## change yy to a factor.

  return(list(useful_inst_names = useful_inst_names,
              useful_inst_idx = useful_inst_idx,
              yy = yy))
}

#' Select Cross Validation folds from MilData
#'
#' Uses the bag information from a `data` object to generate folds for use in
#' cross validation.
#' @param data A MilData object, potentially generated by MilData().
#' @param n_fold the number of folds for cross validation
#' @param fold_id A user specified fold_id. Suggested not to specify
#'   this.
#'
#' @return a list with the following components:
#'   - `n_fold` the number of folds for cross validatoin
#'   - `fold_id` if fold_id is missing in input, returns the folds calculated by
#'   splitting the positive and negative bags separately.
#'
#' @keywords internal
#' @author Yifei Liu, Sean Kent
select_cv_folds <- function(data, n_fold, fold_id) {
  # TODO: I think I can make this a lot cleaner with the following idea from my other code
  # bags_for_train <- which(foldid != fold)
  # ind <- bags %in% unique(bags)[bags_for_train]
  # # The last line goes from the bag index to the instance index, avoiding right joins

  bag_info <- unique(data[, c("bag_label", "bag_name")])
  if (missing(fold_id)) {
    if (missing(n_fold))
      n_fold = 5

    positive_bag_idx <- which(bag_info$bag_label == 1)
    negative_bag_idx <- which(bag_info$bag_label == 0)
    positive_fold_id <- base::sample((1:length(positive_bag_idx))%%n_fold + 1)
    negative_fold_id <- base::sample((1:length(negative_bag_idx))%%n_fold + 1)

    bag_id <- numeric(nrow(bag_info))
    bag_id[positive_bag_idx] <- positive_fold_id
    bag_id[negative_bag_idx] <- negative_fold_id

    temp_data <- data.frame(bag_name = unique(data$bag_name),
                            bag_id = bag_id,
                            stringsAsFactors = FALSE) %>%
      dplyr::right_join(unique(data %>% dplyr::select(bag_name, instance_name)),
                        by = "bag_name")
    fold_id <- temp_data$bag_id  ## now fold_id is of length(unique(data$instance_name))
  } else {
    n_fold <- max(fold_id)
    if (!is.null(setdiff(fold_id, 1:n_fold)))
      stop("The argument fold_id has some 'holes'!")
  }
  return(list(n_fold = n_fold, fold_id = fold_id))
}
